## 实模式
> boot_02.asm

起始 | 结束  | 大小  | 用途 
---  | ---  | ---   | ---
000  | 3FF  | 1KB   | 中断向量表
400  | 4FF  | 256B  | BIOS 数据区
500  | 7BFF | 约30KB| 可用区域
7C00 | 7DFF | 521B  | MBR被BIOS加载到此处
7E00 | 9FBEF| 608KB | 可用区域
9FC00| 9FFFF| 1KB   | 扩展BIOS 数据区
A0000| AFFFF| 64KB  | 用于彩色显示适配器
B0000| B7FFF| 32KB  | 用于黑白显示适配器
B8000| BFFFF| 32KB  | 用于文本模式显示适配器
C0000| C7FFF| 32KB  | 显示适配器BIOS
C8000| EFFFF| 160KB | 映射硬件适配器的ROM或者内存映射式I/O
F0000| FFFEF| 64KB-16B| 系统BIOS范围 减去BIOS入口地址
FFFF0| FFFFF| 16B   | BIOS入口地址

#### BIOS
1. BIOS启动地址0xFFFF0，0xf000:0xfff0.
2. BIOS跳转jmp 0:0x7c00
3. BIOS最后一项工作校验启动盘位于0盘0道1扇区内容
4. 扇区末尾两个字节0x55和0xaa


#### MBR
1. `nasm  mbr.asm -o mbr.bin -l mbr.lst` 获取汇编地址
2. `SECTION 段名` 或 `SEGMENT 段名`
3. `section.data.start` 表示程序0 到section 的偏移量
3. `align=16` 段的对齐方式
4. $ 在当前行行首的标号。 $$ 当前汇编段（section）的起始汇编地址
5.  `vstart=0x7c00` ,表示标号加上vstart值
6. 用户重定位


### 堆栈

>> 1. 有参数先push参数
>> 2. push 保存 下一条指令地址，
>> 3. push 保存 当前栈低。栈底指向性栈顶
>> 4. 开辟 一块空闲缓存栈
>> 5. 获取 内存编号存入edi，计数器 ecx=12,eax,赋值cccccccc。重复循环
>> 6. pop eip

